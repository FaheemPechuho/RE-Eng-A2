%% Code Smell Detection - Project Report
%% LaTeX Version

\documentclass[11pt,a4paper]{article}

% Package imports
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{amssymb}

% Color definitions
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Code listing style
\lstdefinestyle{pythonstyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=Python
}

\lstset{style=pythonstyle}

% Header and footer
\pagestyle{fancy}
\fancyhf{}
\rhead{Code Smell Detection Report}
\lhead{Assignment 2}
\rfoot{Page \thepage}

% Title formatting
\titleformat{\section}{\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\large\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\normalsize\bfseries}{\thesubsubsection}{1em}{}

% Hyperlink setup
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Code Smell Detection Report},
    pdfpagemode=FullScreen,
}

% Document information
\title{\textbf{Code Smell Detection and Analysis} \\ \large{Assignment 2 - Software Reverse Engineering}}
\author{Abdul Faheem (22I-2629) \\ Husnain Akram (22I-2464) \\ Sheryar Ali (22I-2623) \\ BS Software Engineering \\ Section F \\
Github Repository: https://github.com/FaheemPechuho/RE-Eng-A2}

\date{October 5, 2025}

\begin{document}

\maketitle

\begin{abstract}
This report presents a comprehensive code smell detection system for Python source code. The system identifies six common code smells: Long Method, God Class (Blob), Duplicated Code, Large Parameter List, Magic Numbers, and Feature Envy. The project includes a deliberately ``smelly'' Student Grade Management System (245 LOC) with 8 passing unit tests, and a configurable detection application supporting CLI and configuration file customization. The detector successfully identified 63 code smell instances in the test program, demonstrating effectiveness in automated code quality assessment. This work contributes to understanding technical debt, maintainability challenges, and the practical application of static code analysis techniques.
\end{abstract}

\tableofcontents
\newpage

\section{Executive Summary}

This project implements a comprehensive code smell detection system for Python source code. The system identifies six common code smells: Long Method, God Class, Duplicated Code, Large Parameter List, Magic Numbers, and Feature Envy. 

\subsection{Project Components}

The project includes:

\begin{itemize}[noitemsep]
    \item A deliberately ``smelly'' Student Grade Management System (245 LOC)
    \item 8 passing unit tests demonstrating functionality despite code smells
    \item A configurable detection application with CLI and config file support
    \item Comprehensive documentation and testing on multiple code samples
\end{itemize}

\subsection{Key Findings}

\begin{itemize}[noitemsep]
    \item The smelly program contains all 6 targeted code smells
    \item The detector successfully identified 63 code smell instances in the smelly program
    \item The detector is configurable and supports selective smell detection
    \item External sample testing validated the detector's general applicability
\end{itemize}

\section{Introduction}

\subsection{Background}

Code smells are indicators of potential problems in source code. While the code may function correctly, these smells suggest deeper design issues that impact maintainability, readability, and evolution. Detecting and addressing code smells is crucial for managing technical debt.

\subsection{Project Objectives}

\begin{enumerate}[noitemsep]
    \item Create a Python program (200-250 LOC) with intentionally introduced code smells
    \item Develop a detection application capable of identifying all six target smells
    \item Implement flexible configuration through config files and CLI flags
    \item Test the detector and document findings
\end{enumerate}

\subsection{Scope}

This project focuses on six fundamental code smells:

\begin{description}
    \item[Long Method] Methods that are too long and do too much
    \item[God Class (Blob)] Classes with excessive responsibilities
    \item[Duplicated Code] Repeated code blocks
    \item[Large Parameter List] Methods with too many parameters
    \item[Magic Numbers] Hard-coded numeric literals
    \item[Feature Envy] Methods excessively using other classes' data
\end{description}

\section{Deliberately Smelly Code}

\subsection{Overview}

The smelly program is a \textbf{Student Grade Management System} implemented in \texttt{smelly\_code/main.py}. Despite containing multiple code smells, the program is fully functional with 8 passing unit tests.

\begin{table}[h]
\centering
\caption{Smelly Code Statistics}
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Metric} & \textbf{Value} \\
\midrule
Total Lines of Code & 245 LOC \\
Number of Classes & 2 (Student, GradeManagementSystem) \\
Number of Methods & 17 \\
Unit Tests & 8 (100\% pass rate) \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Introduced Code Smells}

\subsubsection{1. Long Method}

\textbf{Location:} Lines 42-86 \\
\textbf{Method:} \texttt{add\_student\_with\_validation\_and\_logging()} \\
\textbf{Length:} 45 lines

\textbf{Why Introduced:} This method intentionally violates the Single Responsibility Principle by performing multiple tasks:

\begin{itemize}[noitemsep]
    \item Student ID validation (lines 43-46)
    \item Name validation (lines 48-52)
    \item Age validation and adult checking (lines 54-59)
    \item Email validation (lines 61-63)
    \item Student object creation (line 66)
    \item Initial grades processing (lines 69-73)
    \item System storage (line 76)
    \item Action logging (lines 79-84)
\end{itemize}

\textbf{Impact:} The method is difficult to test, understand, and modify. Changes to any validation rule require modifying this large method, increasing the risk of introducing bugs.

\begin{lstlisting}[caption={Long Method Example - Multiple Responsibilities}]
def add_student_with_validation_and_logging(self, student_id, name, age, email, initial_grades=None):
    # ID validation
    if not student_id or not isinstance(student_id, str):
        return False
    
    # Name validation  
    if not name or len(name) < 2 or len(name) > 50:
        return False
    
    # Age validation
    if not age or age < 15 or age > 100:
        return False
    
    # ... continues for 45 lines
\end{lstlisting}

\subsubsection{2. God Class (Blob)}

\textbf{Location:} Lines 33-230 \\
\textbf{Class:} \texttt{GradeManagementSystem} \\
\textbf{Metrics:} 12 methods, 198 lines

\textbf{Why Introduced:} The GradeManagementSystem class has been intentionally designed to handle too many responsibilities:

\begin{enumerate}[noitemsep]
    \item \textbf{Student Management:} add, update, remove, retrieve students
    \item \textbf{Grade Calculation:} weighted grades, statistics, letter grades
    \item \textbf{Course Management:} add courses, enroll students
    \item \textbf{Persistence:} save to file
    \item \textbf{History Tracking:} maintain operation logs
\end{enumerate}

\textbf{Impact:} This violates the Single Responsibility Principle. The class should be decomposed into:

\begin{itemize}[noitemsep]
    \item \texttt{StudentRepository} - student CRUD operations
    \item \texttt{GradeCalculator} - grade computations
    \item \texttt{CourseManager} - course operations
    \item \texttt{HistoryLogger} - audit trail
    \item \texttt{DataPersistence} - file I/O
\end{itemize}

\begin{table}[h]
\centering
\caption{Method Count Breakdown}
\begin{tabular}{@{}lc@{}}
\toprule
\textbf{Category} & \textbf{Method Count} \\
\midrule
Student Operations & 4 \\
Grade Operations & 2 \\
Course Operations & 2 \\
Persistence & 1 \\
Utility & 3 \\
\midrule
\textbf{Total} & \textbf{12 (threshold: 10)} \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{3. Duplicated Code}

\textbf{Locations:} Multiple instances across methods

\textbf{Primary Duplications:}

\paragraph{Student ID Validation (3 occurrences):}
\begin{itemize}[noitemsep]
    \item Lines 43-46 in \texttt{add\_student\_with\_validation\_and\_logging()}
    \item Lines 114-117 in \texttt{update\_student\_email()}
    \item Lines 135-138 in \texttt{remove\_student()}
\end{itemize}

\begin{lstlisting}[caption={Duplicated Validation Code}]
# Duplicated in three methods:
if not student_id or not isinstance(student_id, str):
    return False
if student_id not in self.students:
    return False
\end{lstlisting}

\paragraph{Email Validation (2 occurrences):}
\begin{itemize}[noitemsep]
    \item Lines 61-63 in \texttt{add\_student\_with\_validation\_and\_logging()}
    \item Lines 119-121 in \texttt{update\_student\_email()}
\end{itemize}

\begin{lstlisting}[caption={Duplicated Email Validation}]
# Duplicated validation:
if not new_email or '@' not in new_email or '.' not in new_email:
    return False
\end{lstlisting}

\paragraph{Logging Pattern (3 occurrences):}
\begin{itemize}[noitemsep]
    \item Lines 79-84 in \texttt{add\_student\_with\_validation\_and\_logging()}
    \item Lines 125-130 in \texttt{update\_student\_email()}
    \item Lines 142-147 in \texttt{remove\_student()}
\end{itemize}

\begin{lstlisting}[caption={Duplicated Logging Pattern}]
# Duplicated logging:
log_entry = {
    'action': 'operation_name',
    'student_id': student_id,
    'timestamp': str(datetime.now())
}
self.grade_history.append(log_entry)
\end{lstlisting}

\textbf{Impact:}
\begin{itemize}[noitemsep]
    \item \textbf{Maintenance:} Changes require updates in multiple locations
    \item \textbf{Consistency:} Risk of divergent implementations
    \item \textbf{Testing:} Each duplicate needs separate test coverage
\end{itemize}

\subsubsection{4. Large Parameter List}

\textbf{Location:} Lines 89-106 \\
\textbf{Method:} \texttt{calculate\_weighted\_grade()} \\
\textbf{Parameter Count:} 6 parameters (excluding self)

\begin{lstlisting}[caption={Large Parameter List Example}]
def calculate_weighted_grade(
    self, 
    student_id,           # 1
    homework_weight,      # 2
    midterm_weight,       # 3
    final_weight,         # 4
    participation_weight, # 5
    project_weight        # 6
):
\end{lstlisting}

\textbf{Why Introduced:} This method requires six parameters to calculate a weighted grade, making the method difficult to call and understand.

\textbf{Better Approach:} Use a parameter object or configuration dictionary:
\begin{lstlisting}[caption={Improved Design (not implemented)}]
# Improved version:
def calculate_weighted_grade(self, student_id, weights):
    # weights = {'homework': 0.2, 'midterm': 0.25, ...}
\end{lstlisting}

\textbf{Impact:}
\begin{itemize}[noitemsep]
    \item \textbf{Usability:} Difficult to remember parameter order
    \item \textbf{Error-prone:} Easy to swap parameter values
    \item \textbf{Evolution:} Adding new components requires signature changes
\end{itemize}

\subsubsection{5. Magic Numbers}

\textbf{Locations:} Throughout the code

\begin{table}[h]
\centering
\caption{Magic Numbers Found}
\begin{tabular}{@{}clp{5cm}@{}}
\toprule
\textbf{Line} & \textbf{Value} & \textbf{Context} \\
\midrule
55 & 15, 100 & Age validation limits \\
59 & 18 & Adult age check \\
71 & 0, 100 & Grade range validation \\
97 & 5 & Minimum grades count \\
171-177 & 90, 80, 70, 60 & Letter grade thresholds \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Detailed Example:}
\begin{lstlisting}[caption={Magic Numbers in Grade Calculation}]
# Lines 171-177 - Letter grade calculation
if avg >= 90:        # Magic number - why 90?
    letter_grade = 'A'
elif avg >= 80:      # Magic number - why 80?
    letter_grade = 'B'
elif avg >= 70:      # Magic number - why 70?
    letter_grade = 'C'
elif avg >= 60:      # Magic number - why 60?
    letter_grade = 'D'
else:
    letter_grade = 'F'
\end{lstlisting}

\textbf{Better Approach:}
\begin{lstlisting}[caption={Using Named Constants}]
# Define constants at module level:
MIN_STUDENT_AGE = 15
MAX_STUDENT_AGE = 100
ADULT_AGE_THRESHOLD = 18
GRADE_A_CUTOFF = 90
GRADE_B_CUTOFF = 80
# ... etc.
\end{lstlisting}

\textbf{Impact:}
\begin{itemize}[noitemsep]
    \item \textbf{Readability:} Unclear what numbers represent
    \item \textbf{Maintainability:} Hard to find and change policies
    \item \textbf{Consistency:} Same value might be duplicated with different meanings
\end{itemize}

\subsubsection{6. Feature Envy}

\textbf{Location:} Lines 154-188 \\
\textbf{Method:} \texttt{calculate\_student\_statistics()} \\
\textbf{External Access Ratio:} 4/6 (66.7\%)

\begin{lstlisting}[caption={Feature Envy Example}]
def calculate_student_statistics(self, student_id):
    student = self.students[student_id]  # Get student
    
    # Heavy use of student's data (Feature Envy):
    grades = student.get_grades()        # External call 1
    avg = sum(grades) / len(grades)      # Uses external data
    max_grade = max(grades)              # Uses external data
    min_grade = min(grades)              # Uses external data
    
    # ... grade calculation logic ...
    
    return {
        'average': avg,
        'max': max_grade,
        'min': min_grade,
        'letter_grade': letter_grade,
        'student_name': student.get_name()  # External call 2
    }
\end{lstlisting}

\textbf{Why Introduced:} This demonstrates misplaced responsibility. The statistics calculation operates primarily on Student data and should be a Student method.

\textbf{Better Design:}
\begin{lstlisting}[caption={Improved Design}]
# Better design:
class Student:
    def calculate_statistics(self):
        """Calculate my own statistics."""
        grades = self.grades
        # ... calculation logic ...
        return stats
\end{lstlisting}

\textbf{Impact:}
\begin{itemize}[noitemsep]
    \item \textbf{Coupling:} GradeManagementSystem is tightly coupled to Student's structure
    \item \textbf{Cohesion:} Functionality is not where it logically belongs
    \item \textbf{Evolution:} Changes to Student data structure affect GradeManagementSystem
\end{itemize}

\subsection{Unit Tests}

Eight unit tests were implemented to verify functionality:

\begin{enumerate}[noitemsep]
    \item \texttt{test\_add\_student\_success} - Valid student addition
    \item \texttt{test\_add\_student\_invalid\_age} - Age validation
    \item \texttt{test\_add\_student\_invalid\_email} - Email validation
    \item \texttt{test\_calculate\_weighted\_grade} - Weighted grade calculation
    \item \texttt{test\_update\_student\_email} - Email update functionality
    \item \texttt{test\_calculate\_student\_statistics} - Statistics calculation
    \item \texttt{test\_remove\_student} - Student removal
    \item \texttt{test\_course\_enrollment} - Course enrollment
\end{enumerate}

\textbf{Test Results:}
\begin{verbatim}
============================= test session starts =============================
collected 8 items

test_main.py::TestStudentGradeManagementSystem::test_add_student_invalid_age 
    PASSED [ 12%]
test_main.py::TestStudentGradeManagementSystem::test_add_student_invalid_email 
    PASSED [ 25%]
test_main.py::TestStudentGradeManagementSystem::test_add_student_success 
    PASSED [ 37%]
test_main.py::TestStudentGradeManagementSystem::test_calculate_student_statistics 
    PASSED [ 50%]
test_main.py::TestStudentGradeManagementSystem::test_calculate_weighted_grade 
    PASSED [ 62%]
test_main.py::TestStudentGradeManagementSystem::test_course_enrollment 
    PASSED [ 75%]
test_main.py::TestStudentGradeManagementSystem::test_remove_student 
    PASSED [ 87%]
test_main.py::TestStudentGradeManagementSystem::test_update_student_email 
    PASSED [100%]

============================== 8 passed in 0.39s
\end{verbatim}

All tests pass, demonstrating that \textbf{code smells do not prevent functionality} but indicate \textbf{structural problems} that impair maintainability.

\section{Detection Application Design}

\subsection{Architecture}

The detection application follows a modular, extensible architecture using the Strategy and Template Method design patterns.

\subsection{Design Patterns}

\subsubsection{Template Method Pattern}

\texttt{BaseDetector} defines the interface that all detectors must implement:

\begin{lstlisting}[caption={BaseDetector Interface}]
class BaseDetector(ABC):
    @abstractmethod
    def detect(self, ast_tree, source_code, filename):
        """Detect code smells."""
        pass
    
    @abstractmethod
    def get_name(self):
        """Get detector name."""
        pass
    
    def format_smell(self, filename, line_start, line_end, 
                     description, severity):
        """Standard formatting for detected smells."""
        # ... implementation ...
\end{lstlisting}

\subsubsection{Strategy Pattern}

Detectors are interchangeable strategies that can be enabled/disabled:

\begin{lstlisting}[caption={Detector Strategy}]
DETECTOR_CLASSES = {
    'LongMethod': LongMethodDetector,
    'GodClass': GodClassDetector,
    # ... etc.
}
\end{lstlisting}

\subsection{Configuration System}

\subsubsection{Configuration Precedence}

Command-line arguments override configuration file settings:

\begin{enumerate}[noitemsep]
    \item \textbf{Highest Priority:} \texttt{--only} flag (runs ONLY specified detectors)
    \item \textbf{Medium Priority:} \texttt{--exclude} flag (runs all enabled EXCEPT specified)
    \item \textbf{Lowest Priority:} Config file settings (default behavior)
\end{enumerate}

\section{Detection Logic and Thresholds}

\subsection{Long Method Detector}

\textbf{Threshold:} 30 lines (configurable)

\textbf{Detection Logic:}
\begin{lstlisting}[caption={Long Method Detection}]
for node in ast.walk(ast_tree):
    if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
        if hasattr(node, 'lineno') and hasattr(node, 'end_lineno'):
            method_lines = node.end_lineno - node.lineno + 1
            
            if method_lines > threshold:
                # Report smell
\end{lstlisting}

\textbf{Rationale:}
\begin{itemize}[noitemsep]
    \item \textbf{30-line threshold:} Based on research showing methods over 30 lines typically have multiple responsibilities
    \item \textbf{Severity levels:} Medium (30-45 lines), High ($>$ 45 lines)
\end{itemize}

\subsection{God Class Detector}

\textbf{Thresholds:}
\begin{itemize}[noitemsep]
    \item Method Count: 10 methods (configurable)
    \item Line Count: 150 lines (configurable)
\end{itemize}

\textbf{Rationale:}
\begin{itemize}[noitemsep]
    \item \textbf{10-method threshold:} Classes with 10+ methods likely handle multiple responsibilities
    \item \textbf{150-line threshold:} Large classes are harder to understand and maintain
    \item \textbf{OR condition:} Either metric can indicate a God Class
\end{itemize}

\subsection{Duplicated Code Detector}

\textbf{Thresholds:}
\begin{itemize}[noitemsep]
    \item Minimum Lines: 5 (configurable)
    \item Similarity Threshold: 85\% (configurable)
\end{itemize}

\textbf{Similarity Calculation:}
\begin{lstlisting}[caption={Similarity Calculation}]
def _calculate_similarity(self, text1, text2):
    # Normalize whitespace
    normalized1 = ' '.join(text1.split())
    normalized2 = ' '.join(text2.split())
    return SequenceMatcher(None, normalized1, normalized2).ratio()
\end{lstlisting}

\textbf{Rationale:}
\begin{itemize}[noitemsep]
    \item \textbf{5-line minimum:} Shorter blocks are often unavoidable patterns
    \item \textbf{85\% similarity:} Allows for minor variations while catching true duplication
    \item \textbf{Whitespace normalization:} Focuses on structural similarity
\end{itemize}

\subsection{Large Parameter List Detector}

\textbf{Threshold:} 5 parameters (configurable)

\textbf{Rationale:}
\begin{itemize}[noitemsep]
    \item Research shows comprehension decreases sharply after 3-4 parameters
    \item Clean Code (Robert Martin) suggests 3 parameters as maximum
    \item We use 5 as practical threshold allowing some flexibility
\end{itemize}

\subsection{Magic Numbers Detector}

\textbf{Configuration:} Allowed Numbers: [0, 1, -1, 2] (configurable)

\textbf{Rationale:}
\begin{itemize}[noitemsep]
    \item \textbf{0, 1:} Universal concepts (empty, single, identity)
    \item \textbf{-1:} Common sentinel value
    \item \textbf{2:} Binary/pair concept
\end{itemize}

\subsection{Feature Envy Detector}

\textbf{Thresholds:}
\begin{itemize}[noitemsep]
    \item External Call Ratio: 60\% (configurable)
    \item Minimum External Calls: 3 (configurable)
\end{itemize}

\textbf{Rationale:}
\begin{itemize}[noitemsep]
    \item \textbf{60\% threshold:} Majority of operations on external objects suggests misplaced responsibility
    \item \textbf{3 minimum calls:} Avoid false positives from minimal external access
\end{itemize}

\subsection{Threshold Selection Methodology}

All thresholds were selected based on:

\begin{enumerate}[noitemsep]
    \item \textbf{Literature Review:} Research papers and industry standards
    \item \textbf{Tool Comparison:} Analysis of thresholds in PMD, SonarQube, Pylint
    \item \textbf{Practical Testing:} Experimentation with real-world code
    \item \textbf{Configurability:} All thresholds can be adjusted per project needs
\end{enumerate}

\begin{table}[h]
\centering
\caption{Detection Thresholds Summary}
\begin{tabular}{@{}llp{4cm}l@{}}
\toprule
\textbf{Smell} & \textbf{Threshold} & \textbf{Rationale} & \textbf{Source} \\
\midrule
Long Method & 30 lines & Fits on screen & Fowler, Martin \\
God Class & 10 methods / 150 lines & Cognitive load, SRP & Industry \\
Duplicated Code & 5 lines, 85\% & Balance FP/FN & PMD, CPD \\
Large Param List & 5 parameters & Comprehension limit & Clean Code \\
Magic Numbers & Exclude [0,1,-1,2] & Conventions & Multiple \\
Feature Envy & 60\%, 3 min calls & Law of Demeter & Research \\
\bottomrule
\end{tabular}
\end{table}

\section{Testing and Results}

\subsection{Test Setup}

\textbf{Test Subjects:}
\begin{enumerate}[noitemsep]
    \item \textbf{Primary:} \texttt{smelly\_code/main.py} (deliberately smelly program)
    \item \textbf{External:} \texttt{external\_sample.py} (calculator with some smells)
\end{enumerate}

\textbf{Test Environment:}
\begin{itemize}[noitemsep]
    \item Python 3.11.9
    \item Windows 10
    \item PyYAML 6.0
    \item pytest 8.4.2
\end{itemize}

\subsection{Results: Smelly Code Analysis}

\textbf{Summary:}
\begin{itemize}[noitemsep]
    \item \textbf{Total Smells Detected:} 63
    \item \textbf{Analysis Time:} $<$ 1 second
    \item \textbf{File Size:} 245 lines
\end{itemize}

\begin{table}[h]
\centering
\caption{Breakdown by Smell Type}
\begin{tabular}{@{}lcc@{}}
\toprule
\textbf{Smell Type} & \textbf{Count} & \textbf{Severity} \\
\midrule
Long Method & 2 & 2 medium \\
God Class & 1 & 1 high \\
Duplicated Code & 41 & 41 low \\
Large Parameter List & 2 & 2 medium \\
Magic Numbers & 15 & 15 low \\
Feature Envy & 2 & 2 medium \\
\midrule
\textbf{Total} & \textbf{63} & -- \\
\bottomrule
\end{tabular}
\end{table}

\subsection{CLI Feature Testing}

\subsubsection{Test 1: Selective Detection (--only)}

\textbf{Command:}
\begin{verbatim}
python main.py --only LongMethod,GodClass ../smelly_code/main.py
\end{verbatim}

\textbf{Result:} Only specified detectors ran ✓

\subsubsection{Test 2: Exclusion (--exclude)}

\textbf{Command:}
\begin{verbatim}
python main.py --exclude DuplicatedCode,MagicNumbers ../smelly_code/main.py
\end{verbatim}

\textbf{Result:} Excluded detectors didn't run ✓

\subsubsection{Test 3: JSON Output}

\textbf{Command:}
\begin{verbatim}
python main.py --format json --output report.json ../smelly_code/main.py
\end{verbatim}

\textbf{Result:} JSON file created with structured data ✓

\section{Technical Debt and Maintainability}

\subsection{Impact of Code Smells}

\begin{table}[h]
\centering
\caption{Quantitative Impact of Code Smells}
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{Smell Type} & \textbf{Maintenance} & \textbf{Bug Rate} & \textbf{Comprehension} \\
 & \textbf{Cost} & \textbf{Increase} & \textbf{Time} \\
\midrule
Long Method & +40-60\% & +50\% & +70\% \\
God Class & +100-200\% & +75\% & +150\% \\
Duplicated Code & +60-80\% & +200\% & +50\% \\
Large Param List & +30-40\% & +40\% & +35\% \\
Magic Numbers & +20-30\% & +60\% & +40\% \\
Feature Envy & +40-50\% & +30\% & +45\% \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Technical Debt Metrics}

\textbf{Technical Debt Ratio} (estimated):

\begin{equation}
TD~Ratio = \frac{Remediation~Cost}{Development~Cost}
\end{equation}

For \texttt{smelly\_code/main.py}:
\begin{itemize}[noitemsep]
    \item Estimated remediation: 8-12 hours
    \item Original development: $\sim$6 hours
    \item TD Ratio: 133-200\%
\end{itemize}

This high ratio indicates significant accumulated debt despite recent development.

\subsection{Maintainability Index}

Using a simplified maintainability index calculation:

\begin{equation}
MI = 171 - 5.2 \times \ln(V) - 0.23 \times G - 16.2 \times \ln(LOC)
\end{equation}

Where:
\begin{itemize}[noitemsep]
    \item $V$ = Halstead Volume (complexity)
    \item $G$ = Cyclomatic Complexity
    \item $LOC$ = Lines of Code
\end{itemize}

For GradeManagementSystem class:
\begin{itemize}[noitemsep]
    \item LOC: 198
    \item Estimated $G$: $\sim$45 (high)
    \item Estimated $V$: $\sim$800
\end{itemize}

\begin{align*}
MI &\approx 171 - 5.2 \times 6.68 - 0.23 \times 45 - 16.2 \times 5.29 \\
MI &\approx 171 - 34.7 - 10.4 - 85.7 \\
MI &\approx 40.2
\end{align*}

\textbf{Interpretation:}
\begin{itemize}[noitemsep]
    \item 85-100: Highly maintainable
    \item 65-84: Moderately maintainable
    \item 0-64: Difficult to maintain
\end{itemize}

\textbf{Result:} Score of $\sim$40 indicates \textbf{difficult to maintain} code, validating our smell detections.

\section{Conclusion}

\subsection{Summary of Achievements}

This project successfully:

\begin{enumerate}[noitemsep]
    \item ✓ Created a functional program with intentionally introduced code smells
    \item ✓ Implemented 8 passing unit tests (100\% pass rate)
    \item ✓ Developed a comprehensive smell detection tool
    \item ✓ Implemented configurable detection with CLI override support
    \item ✓ Tested on multiple code samples
    \item ✓ Documented all smells and detection logic
\end{enumerate}

\subsection{Key Findings}

\begin{enumerate}[noitemsep]
    \item \textbf{Code Smells Are Prevalent:} Even in small programs (245 LOC), numerous smells can accumulate
    \item \textbf{Functionality $\neq$ Quality:} All tests pass, but code quality is poor
    \item \textbf{Detection Is Feasible:} Static analysis can effectively identify common smells
    \item \textbf{Configuration Is Crucial:} Different projects need different thresholds
    \item \textbf{Technical Debt Compounds:} Smells interact and amplify maintenance costs
\end{enumerate}

\subsection{Detector Effectiveness}

\textbf{Strengths:}
\begin{itemize}[noitemsep]
    \item Successfully detected all intentionally introduced smells
    \item Configurable and extensible architecture
    \item Multiple output formats
    \item Fast performance ($<$ 1s for 245 LOC)
    \item User-friendly CLI
\end{itemize}

\textbf{Limitations:}
\begin{itemize}[noitemsep]
    \item Limited to Python source code
    \item Some false positives (e.g., overlapping duplications)
    \item Doesn't detect all smell types (e.g., shotgun surgery, message chains)
    \item Threshold-based detection may miss context-dependent issues
\end{itemize}

\subsection{Final Thoughts}

Code smells are early warning signs of design problems. While the smelly program functions correctly, it would be increasingly difficult to maintain as requirements evolve. The detection tool provides automated support for identifying these issues, but human judgment remains essential for determining remediation priorities and approaches.

\textbf{Technical debt is not inherently bad} -- it's a tool for managing tradeoffs. However, \textbf{unmanaged technical debt} leads to:
\begin{itemize}[noitemsep]
    \item Slower feature delivery
    \item Higher bug rates
    \item Developer frustration
    \item System fragility
\end{itemize}

Regular smell detection, combined with disciplined refactoring, helps teams maintain code quality and delivery velocity over time.

\begin{thebibliography}{9}

\bibitem{fowler2018}
Fowler, M. (2018). \textit{Refactoring: Improving the Design of Existing Code} (2nd ed.). Addison-Wesley.

\bibitem{martin2008}
Martin, R. C. (2008). \textit{Clean Code: A Handbook of Agile Software Craftsmanship}. Prentice Hall.

\bibitem{yamashita2013}
Yamashita, A., \& Moonen, L. (2013). Exploring the impact of inter-smell relations on software maintainability. \textit{ICSE 2013}.

\bibitem{kim2012}
Kim, M., Zimmermann, T., \& Nagappan, N. (2012). A field study of refactoring challenges and benefits. \textit{FSE 2012}.

\bibitem{tufano2015}
Tufano, M., et al. (2015). When and why your code starts to smell bad. \textit{ICSE 2015}.

\bibitem{pmd}
PMD - Source Code Analyzer. \url{https://pmd.github.io/}

\bibitem{sonarqube}
SonarQube - Code Quality and Security. \url{https://www.sonarqube.org/}

\end{thebibliography}

\appendix

\section{Appendix A: Code Listings}

Complete source code is available in the project repository at:
\begin{itemize}[noitemsep]
    \item \texttt{smelly\_code/main.py} - Deliberately smelly program
    \item \texttt{detector/main.py} - Detection application
    \item \texttt{detector/detectors/} - Individual detector implementations
\end{itemize}

\section{Appendix B: Configuration Files}

\subsection{config.yaml}

\begin{lstlisting}[language=yaml,caption={Detector Configuration File}]
# Code Smell Detector Configuration
detectors:
  LongMethod:
    enabled: true
    threshold: 30
  
  GodClass:
    enabled: true
    method_threshold: 10
    line_threshold: 150
  
  DuplicatedCode:
    enabled: true
    min_lines: 5
    similarity_threshold: 0.85
  
  LargeParameterList:
    enabled: true
    threshold: 5
  
  MagicNumbers:
    enabled: true
    allowed_numbers: [0, 1, -1, 2]
  
  FeatureEnvy:
    enabled: true
    external_call_ratio: 0.6
    min_external_calls: 3
\end{lstlisting}

\end{document}

